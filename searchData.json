[{"title":"android构建工具-Gradle","url":"/2018/12/28/android构建工具-Gradle/","content":"\n#### Question\n\n>Android Studio中自带的构建工具Gradle,如何构建的Android程序？\n>Gradle的工作机制是什么？\n>Gradle一般用来干什么？\n\n### Preface\n\n学过两节课的gradle课程，还是没能对gradle有一个清晰的认知","tags":["Android-Studio Gradle"]},{"title":"RxJava从操作符到内部流程（1）","url":"/2018/12/27/RxJava从操作符到内部流程（1）/","content":"\n又整了半天的hexo博客，终于搞定了主题和基本操作。可能没事干的程序员总得想法设法的找点事情让自己显得忙一点。\n\n\n\n","tags":["Rxjava"]},{"title":"RxJava 学习计划","url":"/2018/12/26/RxJava-学习计划/","content":"\n &nbsp;&nbsp;&nbsp;&nbsp;从14年Rxjava第一次面世到17年，已经迭代到了2.x,不管对于Android还是java来说异步的思想，打破了我们传统的做法，之前看过扔物线的rxjava，里面提到rxjava的核心思想是异步。我自己使用Rxjava也有几个月了，因为没有去很具体的归纳，很多操作符都只是停留在使用上面，很羞愧的说，很多操作符都记不住作用，但是余以为这些都不关键，编程重在思想，我那点问题难道不能忽略么，是吧？ \n\n &nbsp;&nbsp;&nbsp;&nbsp;好了闲话不多，说说这次计划的具体安排，我自己准备总共花费大概两周的时间，从哲学的角度全面分析：“我是谁？我在哪？谁打我？我怎么死了？”这三个问题展开对rxjava的攻坚。主要的策略是源码和官方文档，届时我蹩脚的英语CET-4又能发挥一点作用，其实想到这里我是拒绝的。\n \n （ps:时间其实没那么充裕，尽量做到从使用到理解，从理解到深入，直到理解思想，当然没有理想不丰满）\n\n &nbsp;&nbsp;&nbsp;&nbsp;这里就需要说一下如何去学，又如何去写一个知识点，做到什么程度，等等一些问题，也借这几个问题分析一下要去掌握的主要内容。说实在的我是首次接触写博客，肯定避免不了一些纰漏，和错误，希望能及时指出共同进步。\n\n##### 如何去学？\n\n &nbsp;&nbsp;&nbsp;&nbsp;前面也说到其实对rxjava也有一些了解，但是还是处于门外汉的级别，那么对于一个完全陌生的东西要怎么去掌握呢？最好的方式是用自己熟悉的东西去拟合，那样所有的知识之间的联系会更深，也可以帮助我们去了解它。</br>\n &nbsp;&nbsp;&nbsp;&nbsp;对于RxJava，我们熟悉的有 ： 观察者模式、异步。</br>\n &nbsp;&nbsp;&nbsp;&nbsp;陌生的就是Rxjava的演变既 ：Reactive-stream </br>\n &nbsp;&nbsp;&nbsp;&nbsp;本次的计划第一步的中心放在熟悉和陌生的知识点上，观察者模式建议去看设计模式之禅（看完之后你肯定也有向我一样惊讶，竟然有人能把一个东西写的如此通俗易懂），异步和后者将在本周完成。\n\n* single dependency: Reactive-Streams\n* continued support for Java 6+ & Android 2.3+\n* performance gains through design changes learned through the 1.x cycle and through Reactive-Streams-Commons research project.\n* Java 8 lambda-friendly API\n* non-opinionated about source of concurrency (threads, pools, event loops, fibers, actors, etc)\nasync or synchronous execution\n* virtual time and schedulers for parameterized concurrency\n\n这是RxJava2的一些描述\n\n\n\n\n\n##### 如何去写？\n \n &nbsp;&nbsp;&nbsp;&nbsp;如何去写，这个问题其实我及不擅长。什么作文都能写成散文，貌合神离用来形容最贴切不过了，不管怎么样先写再说。\n\n##### 到什么程度？\n\n &nbsp;&nbsp;&nbsp;&nbsp;程度最好到能体会到思想，当然最基本的使用是必须的，场景分析和那些情况适合用RxJava也必须列入考虑。如果不出意外的话，将用三篇博客来完成，这个内容。 RxJava的使用---之操作符全家桶、蕴含Rxjava中的思想、从Rxjava中学到什么。\n\n### 结语\n\n &nbsp;&nbsp;&nbsp;&nbsp;婚都没结，结什么语\n\n### 附录\n\n &nbsp;&nbsp;&nbsp;&nbsp;[设计模式之禅](https://github.com/ZhouKanZ/designPattern/blob/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%EF%BC%88%E7%AC%AC2%E7%89%88%EF%BC%89.pdf)\n\n\n\n \n \n\n \n\n\n\n\n \n \n\n","tags":["Rxjava"]},{"title":"java8 Lambda表达式","url":"/2018/12/26/Java8-lambda表达式/","content":"\n### Tips\n\n本篇文章主要是RxJava官方文档的辅料，里面太多的Lambda表达式，没有一些了解的确难以看懂，因为是主要的重心还是落在RxJava上，所以本文概述一下如何在Android Studio中使用以及各个表达式的意思，还有与Rxjava及其相似的stream。[官方文档](http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/Lambda-QuickStart/index.html#)如何描述Lambda表达式：\n\n>  Lambda expressions are a new and important feature included in Java SE 8. They provide a clear and concise way to represent one method interface using an expression. Lambda expressions also improve the Collection libraries making it easier to iterate through, filter, and extract data from a Collection. In addition, new concurrency features improve performance in multicore environments.\n\n这段话指出了在java8中lambda表达式三个主要的作用：简洁的方式呈现接口；提高集合迭代，过滤和扩展的性能；提高多核环境下并发的性能。具体的翻译还是大家自行去理解，中英转换肯定会出现一定的偏差。\n\n### 软硬件环境\n\n* JDK 8\n* NetBeans 7.4 （这个只是IDE 在Android Studio中同样是可以使用的）\n\n### Lambda应用场景\n\n#### Anonymous Inner Class\n\t\n 匿名内部类，用过java的人这个应该都知道就不再赘述\n\n\n\n ```java\n\t// 匿名内部类\n\tJButton jb1 = new JButton();\n\tjb1.addActionListener(new ActionListener() {\n\t    @Override\n\t    public void actionPerformed(ActionEvent e) {\n\t        System.out.println(\"xxx\");\n\t    }\n\t});\n    // lambda表达式的方式\n\tJButton jb = new JButton();\n\tjb.addActionListener((e) -> System.out.println());\n```\n\n#### Functional Interface\n\n在java中，一个interface里面只有一个需要实现的方法，这种形式的接口就被称作为Functional Interface,也被叫做SAM.(Single Abstract Method)\n\n```\n\tpublic interface ActionListener extends EventListener {\n\t\n\t    /**\n\t     * Invoked when an action occurs.\n\t     */\n\t    public void actionPerformed(ActionEvent e);\n\t\n\t}\n```\n\n#### Lambda Expression Syntax \n\n λ表达式的语法，通常λ表达式可以将5行代码，转换成一行代码来表示，上面的匿名内部类便是例子，λ表达式的语法由如下三个部分组成：\n\n|参数列表|箭头|方法体|\n| ------------- |:-------------|:-------------|\n|（int x,int y）|->|x + y|\n\n\n### lambda表达式实例\n\n\n#### Listener Lambda\n\n```\n\tprivate static void listenerLambda() {\n        //        Listener Lambda\n        JButton jb1 = new JButton();\n        jb1.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                System.out.println(\"xxx\");\n            }\n        });\n\n        // lambda表达式的方式\n        JButton jb = new JButton();\n        jb.addActionListener((e) -> System.out.println());\n    }\n```\n\n#### Comparator Lambda\n\n```\n    private static void compatorLambda() {\n        // sort with inner class\n        List<Person> personList = new ArrayList<>();\n        personList.add(new Person(\"zk\"));\n        personList.add(new Person(\"ak\"));\n\n\n        System.out.println(\"sort with inner class\");\n        Collections.sort(personList, new Comparator<Person>() {\n            @Override\n            public int compare(Person o1, Person o2) {\n                // 按照字典序排列 person\n                return o1.getSurName().compareTo(o2.getSurName());\n            }\n        });\n\n        for (Person p:\n                personList) {\n            System.out.println(p.getSurName());\n        }\n\n\n        System.out.println(\"sort with lambda\");\n        // sort with lambda\n        Collections.sort(personList, (p1,p2)->p1.getSurName().compareTo(p2.getSurName()));\n        for (Person p:\n                personList) {\n            System.out.println(p.getSurName());\n        }\n    }\n```\n\n#### Runnable Lambda\n\n```\n    private static void runnableLambda() {\n        // 传统模式\n        Runnable r1 = new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(\"Tran  A\");\n                System.out.println(\"Tran  B\");\n            }\n        };\n\n        // lambda\n        Runnable r2 = () -> System.out.print(\"Lambda  A\");\n        System.out.print(\"Lambda  B\");\n\n        r1.run();\n        r2.run();\n    }\n```\n\n## Improving Code with Lambda Expression \n\n 使用Lambda优化代码。代码优化这件事可轻可重，像我写代码的主要目的就是奔着功能去，一往无前，有bug回头改,往往都是一去不返。代码优化有很多方面，像6大设计原则，23种设计模式等等，今天得例子要验证得Principle叫做 --- 'Don't Repeat Yourself ' 简称 (DRY)，不得不说所有得原则全称都不如简称有格调。\n\n 那下面我们就来验证一下lambda相对于原有得做法到底 DRY 在哪里：\n\n> 1.场景 \n  \n 有一群人来面试,只招聘司机、应征入伍、飞行员，面试得条件如下：\n \t\n\t司机 ： 年纪超过16\n    入伍 ： 男性年龄在18-25之间\n    飞行员：年龄在23 到 65之间\n\n Person 字段 \n\n```\n\tpublic class Person {\n    private String givenName;\n    private String surName;\n    private int age;\n    private Gender gender;\n    private String eMail;\n    private String phone;\n    private String address;\t\n    }\n```\n\n> 2.创建person List\n\n   怎么创建比较随意，我这里就按照官网得方式来创建（在上一篇RxJava中有关于设计模式得附录）\n\n```\n   \tpublic static List<Person> createShortList() {\n        List<Person> people = new ArrayList<>();\n        people.add(\n                new Person.Builder().\n                        givenName(\"Bob\")\n                        .surName(\"Baker\")\n                        .age(21)\n                        .gender(Gender.MALE)\n                        .email(\"bob.baker@example.com\")\n                        .phoneNumber(\"201-121-4678\")\n                        .address(\"44 4th St, Smallville, KS 12333\")\n                        .build()\n        );\n        people.add(\n                new Person.Builder()\n                        .givenName(\"Jane\")\n                        .surName(\"Doe\")\n                        .age(25)\n                        .gender(Gender.FEMALE)\n                        .email(\"jane.doe@example.com\")\n                        .phoneNumber(\"202-123-4678\")\n                        .address(\"33 3rd St, Smallville, KS 12333\")\n                        .build()\n        );\n        people.add(\n                new Person.Builder()\n                        .givenName(\"John\")\n                        .surName(\"Doe\")\n                        .age(25)\n                        .gender(Gender.MALE)\n                        .email(\"john.doe@example.com\")\n                        .phoneNumber(\"202-123-4678\")\n                        .address(\"33 3rd St, Smallville, KS 12333\")\n                        .build()\n        );\n\n        return people;\n    }\n\n```\n> 3. 选出满足条件的人\n\n```\n\tpublic class RoboContactMethods {\n\n\t    public void callDrivers(List<Person> pl) {\n\t        for (Person p : pl) {\n\t            if (p.getAge() >= 16) {\n\t                roboCall(p);\n\t            }\n\t        }\n\t    }\n\t\n\t    public void emailDraftees(List<Person> pl) {\n\t        for (Person p : pl) {\n\t            if (p.getAge() >= 18 && p.getAge() <= 25 && p.getGender() == Gender.MALE) {\n\t                roboEmail(p);\n\t            }\n\t        }\n\t    }\n\t\n\t    public void mailPilots(List<Person> pl) {\n\t        for (Person p : pl) {\n\t            if (p.getAge() >= 23 && p.getAge() <= 65) {\n\t                roboMail(p);\n\t            }\n\t        }\n\t    }\n\t\n\t    public void roboCall(Person p) {\n\t        System.out.println(\"Calling \" + p.getGivenName() + \" \" + p.getSurName() + \" age \" + p.getAge() + \" at \" + p.getPhone());\n\t    }\n\t\n\t    public void roboEmail(Person p) {\n\t        System.out.println(\"EMailing \" + p.getGivenName() + \" \" + p.getSurName() + \" age \" + p.getAge() + \" at \" + p.geteMail());\n\t    }\n\t\n\t    public void roboMail(Person p) {\n\t        System.out.println(\"Mailing \" + p.getGivenName() + \" \" + p.getSurName() + \" age \" + p.getAge() + \" at \" + p.getAddress());\n\t    }\n\t}\n```\n\n我看这段代码是没问题的，for循环迭代选出满足条件的人，完全没毛病；那我们来看看官方的犊子是怎么演的。\n\n* 没有遵循DRY原则\n\t- 每个方法的选择条件必须重写\n\t- 每个方法都重复循环\n* 需要大量方法来实现每个用例\n* 上述代码不灵活，如果招聘条件发生变化，那么将引起大量的更改，可维护性不强\n\n\n>4.第一次重构\n\t\n 这次我们将上述的几个问题列入考虑，其实，我感觉我的翻译貌似出了点小差错，或者是我没明白他是什么意思，除了最后一项可以理解之外，其他的情况没弄懂是什么意思，再或者是本身语言的限制只能优化最后一项，那么下面看看，该如何重构。\n\n```\npublic class RoboContactMethods2 {\n\n        public void callDrivers(List<Person> pl) {\n            for (Person p : pl) {\n                if (isDriver(p)) {\n                    roboCall(p);\n                }\n            }\n        }\n\n        public void emailDraftees(List<Person> pl) {\n            for (Person p : pl) {\n                if (isDraftee(p)) {\n                    roboEmail(p);\n                }\n            }\n        }\n\n        public void mailPilots(List<Person> pl) {\n            for (Person p : pl) {\n                if (isPilot(p)) {\n                    roboMail(p);\n                }\n            }\n        }\n\n        public boolean isDriver(Person p) {\n            return p.getAge() >= 16;\n        }\n\n        public boolean isDraftee(Person p) {\n            return p.getAge() >= 18 && p.getAge() <= 25 && p.getGender() == Gender.MALE;\n        }\n\n        public boolean isPilot(Person p) {\n            return p.getAge() >= 23 && p.getAge() <= 65;\n        }\n\n        public void roboCall(Person p) {\n            System.out.println(\"Calling \" + p.getGivenName() + \" \" + p.getSurName() + \" age \" + p.getAge() + \" at \" + p.getPhone());\n        }\n\n        public void roboEmail(Person p) {\n            System.out.println(\"EMailing \" + p.getGivenName() + \" \" + p.getSurName() + \" age \" + p.getAge() + \" at \" + p.geteMail());\n        }\n\n        public void roboMail(Person p) {\n            System.out.println(\"Mailing \" + p.getGivenName() + \" \" + p.getSurName() + \" age \" + p.getAge() + \" at \" + p.getAddress());\n        }\n\n}\n```\n\n 搜索条件被封装进方法中，较之前的代码而言确实有一定的提升，条件可以被反复利用并且可以更方便的更改。但是，还是有很多重复的地方，是不是没有更好的办法呢？（······肯定是有的，要不我说个球）\n\n 在使用lambda之前先看看还有什么能改进的或者是为lambda做一些铺垫。上述的代码，其实并不符合开闭原则（OCP -- 原则上对修改关闭，对扩展开放），这段程序可能发生改变是招聘条件，那么我们让调用程序自己去维护，就更进一步的优化了。\n \n 将条件抽象成接口，让调用者自己去维护，接口如下：\n \n ```\n\t public interface MyTest<T> {\n\t   public boolean test(T t);\n\t }\n```\n\n\n> RoboContactsAnon.java\n\n\n```\n  \tpackage com.example.lambda;\n  \timport java.util.List;\n  \timport java.util.function.Predicate;\n\n    /**\n     * @author MikeW\n     */\n    public class RoboContactsAnon {\n        public void phoneContacts(List<Person> pl, MyTest<Person> pred) {\n            for (Person p : pl) {\n                if (pred.test(p)) {\n                    roboCall(p);\n                }\n            }\n        }\n\n        public void emailContacts(List<Person> pl, MyTest<Person> pred) {\n            for (Person p : pl) {\n                if (pred.test(p)) {\n                    roboEmail(p);\n                }\n            }\n        }\n\n        public void mailContacts(List<Person> pl, MyTest<Person> pred) {\n            for (Person p : pl) {\n                if (pred.test(p)) {\n                    roboMail(p);\n                }\n            }\n        }\n\n        public void roboCall(Person p) {\n            System.out.println(\"Calling \" + p.getGivenName() + \" \" + p.getSurName() + \" age \" + p.getAge() + \" at \" + p.getPhone());\n        }\n\n        public void roboEmail(Person p) {\n            System.out.println(\"EMailing \" + p.getGivenName() + \" \" + p.getSurName() + \" age \" + p.getAge() + \" at \" + p.getEmail());\n        }\n\n        public void roboMail(Person p) {\n            System.out.println(\"Mailing \" + p.getGivenName() + \" \" + p.getSurName() + \" age \" + p.getAge() + \" at \" + p.getAddress());\n        }\n    }\n```\n\n> RoboCallTest03.java 调用程序\n\n```\n\tpublic class RoboCallTest03 {\n\n\t    public static void main(String[] args) {\n\t\n\t      List<Person> pl = Person.createShortList();\n\t      RoboContactsAnon robo = new RoboContactsAnon();\n\t\n\t      System.out.println(\"\\n==== Test 03 ====\");\n\t      System.out.println(\"\\n=== Calling all Drivers ===\");\n\t      robo.phoneContacts(pl,\n\t          new MyTest<Person>(){\n\t            @Override\n\t            public boolean test(Person p){\n\t              return p.getAge() >=16;\n\t            }\n\t          }\n\t      );\n\t\n\t      System.out.println(\"\\n=== Emailing all Draftees ===\");\n\t      robo.emailContacts(pl,\n\t          new MyTest<Person>(){\n\t            @Override\n\t            public boolean test(Person p){\n\t              return p.getAge() >= 18 && p.getAge() <= 25 && p.getGender() == Gender.MALE;\n\t            }\n\t          }\n\t      );\n\t\n\t\n\t      System.out.println(\"\\n=== Mail all Pilots ===\");\n\t      robo.mailContacts(pl,\n\t          new MyTest<Person>(){\n\t            @Override\n\t            public boolean test(Person p){\n\t              return p.getAge() >= 23 && p.getAge() <= 65;\n\t            }\n\t          }\n\t      );\n   \t  }\n\t}\n```\n  仅通过java8之前得方式，程序看起来已经符合OCP的原则；在前面提到过SAM这种形式是可以用，lambda来表示的。那么看看如何去用lambda,来进一步的优化上面的程序\n\n> lambda 优化\n\n 在java.util.function包中提供了一种形式类似的MyTest的接口，Predicate<T>：\n \n```\n\tpublic interface Predicate<T> {\n\t   public boolean test(T t);\n\t}\n\n```\n\n> RoboContactsLambda.java\n\n\n```\n    package com.example.lambda;\n    import java.util.List;\n    import java.util.function.Predicate;\n\n    /**\n     * @authorzhoukan\n     */\n    public class RoboContactLambda {\n        public void phoneContacts(List<Person> pl, Predicate<Person> pred) {\n            for (Person p : pl) {\n                if (pred.test(p)) {\n                    roboCall(p);\n                }\n            }\n        }\n\n        public void emailContacts(List<Person> pl, Predicate<Person> pred) {\n            for (Person p : pl) {\n                if (pred.test(p)) {\n                    roboEmail(p);\n                }\n            }\n        }\n\n        public void mailContacts(List<Person> pl, Predicate<Person> pred) {\n            for (Person p : pl) {\n                if (pred.test(p)) {\n                    roboMail(p);\n                }\n            }\n        }\n\n        public void roboCall(Person p) {\n            System.out.println(\"Calling \" + p.getGivenName() + \" \" + p.getSurName() + \" age \" + p.getAge() + \" at \" + p.getPhone());\n        }\n\n        public void roboEmail(Person p) {\n            System.out.println(\"EMailing \" + p.getGivenName() + \" \" + p.getSurName() + \" age \" + p.getAge() + \" at \" + p.getEmail());\n        }\n\n        public void roboMail(Person p) {\n            System.out.println(\"Mailing \" + p.getGivenName() + \" \" + p.getSurName() + \" age \" + p.getAge() + \" at \" + p.getAddress());\n        }\n    }\n\n```\n\n Mytest接口被更换成了Predicate,调用程序的代码片段如下\n\n```\n\tpublic static void main(String[] args){ \n\t\t\n\t\t List<Person> pl = Person.createShortList();\n\t     RoboContactLambda robo = new RoboContactLambda();\n\n\t\t Predicate<Person> allDrivers = p -> p.getAge() >= 16;\n         robo.phoneContacts(pl, allDrivers);\n\t}\n```\n 当然即使不适用util.function提供的接口，也是可以实现了，只要满足lambda表达式的场景就好：\n```\n   \t\trobo.mailContacts(pl,\n          /*new MyTest<Person>(){\n            @Override\n            public boolean test(Person p){\n              return p.getAge() >= 23 && p.getAge() <= 65;\n            }\n          }*/\n                (p) -> p.getAge() > 23 && p.getAge() <= 65\n        );\n```\n\n## The java.util.function 包\n\n\n function包提供了几种方便去使用lambda的interface，当然不仅仅是给lambda表达式使用，所有诸如上述的优化都是可以考虑用这些方法的，确实我看到这里就有点抑制不住内心的小狂喜，lambda的这些function不就是Rxjava中常用的操作符嘛，这么麻烦的工作算是没白做，就下面的需求，我们来体验一下她的魅力。\n\n* Predicate: A property of the object passed as argument\n* Consumer: An action to be performed with the object passed as argument\n* Function: Transform a T to a U\n* Supplier: Provide an instance of a T (such as a factory)\n* UnaryOperator: A unary operator from T -> T\n* BinaryOperator: A binary operator from (T, T) -> T\n\n\n> 输出东方人和西方人的信息\n \n  上面的personList（求职者），要将他们的信息分别发给，老板和老板娘，他们一个是中国人，一个是美国人；由于习惯不同，西方习惯姓在后名在前（分别对应Given name 和 surname），中国的习惯我就不提了。\n\n#### 传统的方式\n\n> person.java\n\n\n```\npublic void printWesternName() {\n\n    System.out.println(\"\\nName: \" + this.getGivenName() + \" \" + this.getSurName() + \"\\n\" +\n            \"Age: \" + this.getAge() + \"  \" + \"Gender: \" + this.getGender() + \"\\n\" +\n            \"EMail: \" + this.geteMail() + \"\\n\" +\n            \"Phone: \" + this.getPhone() + \"\\n\" +\n            \"Address: \" + this.getAddress());\n}\n\npublic void printEasternName() {\n\n    System.out.println(\"\\nName: \" + this.getSurName() + \" \" + this.getGivenName() + \"\\n\" +\n            \"Age: \" + this.getAge() + \"  \" + \"Gender: \" + this.getGender() + \"\\n\" +\n            \"EMail: \" + this.geteMail() + \"\\n\" +\n            \"Phone: \" + this.getPhone() + \"\\n\" +\n            \"Address: \" + this.getAddress());\n}\n\n```\n\n\n#### 使用Function Interface的方式\n \n```\npublic interface Function<R,T>{\n    public R apply(T t);\n}\n\n```\n\n  指定两个泛型以T作为输入，R作为输出，那么对于上述场景而言 -> Function<string,person>，用function来更灵活的实现打印方法：\n  \n  Person.java\n\n```\n\tpublic String printCustom(Function <Person, String> f){\n\t      return f.apply(this);\n\t}\n```\n\n> 调用程序 NameTestNew.java\n\n```\n  \tpublic class NameTestNew {\n        public static void main(String[] args) {\n\n            System.out.println(\"\\n==== NameTestNew02 ===\");\n\n            List<Person> list1 = Person.createShortList();\n\n            // Print Custom First Name and e-mail\n            System.out.println(\"===Custom List===\");\n            for (Person person : list1) {\n                System.out.println(\n                        person.printCustom(p -> \"Name: \" + p.getGivenName() + \" EMail: \" + p.getEmail())\n                );\n            }\n\n\n            // Define Western and Eastern Lambdas\n\n            Function<Person, String> westernStyle = p -> {\n                return \"\\nName: \" + p.getGivenName() + \" \" + p.getSurName() + \"\\n\" +\n                        \"Age: \" + p.getAge() + \"  \" + \"Gender: \" + p.getGender() + \"\\n\" +\n                        \"EMail: \" + p.getEmail() + \"\\n\" +\n                        \"Phone: \" + p.getPhone() + \"\\n\" +\n                        \"Address: \" + p.getAddress();\n            };\n\n            Function<Person, String> easternStyle = p -> \"\\nName: \" + p.getSurName() + \" \"\n                    + p.getGivenName() + \"\\n\" + \"Age: \" + p.getAge() + \"  \" +\n                    \"Gender: \" + p.getGender() + \"\\n\" +\n                    \"EMail: \" + p.getEmail() + \"\\n\" +\n                    \"Phone: \" + p.getPhone() + \"\\n\" +\n                    \"Address: \" + p.getAddress();\n\n            // Print Western List\n            System.out.println(\"\\n===Western List===\");\n            for (Person person : list1) {\n                System.out.println(\n                        person.printCustom(westernStyle)\n                );\n            }\n\n            // Print Eastern List\n            System.out.println(\"\\n===Eastern List===\");\n            for (Person person : list1) {\n                System.out.println(\n                        person.printCustom(easternStyle)\n                );\n            }\n\n\n        }\n    } \n```\n 第一次循环只输出了名和email,所有有效的表达式都能作为printCustom的参数；第二次，首先将东方人和西方人的输出方式定义为Fucntion，并当作参数传入printCustom中。lambda表达式利于扩展和反复利用的优势得以体现。\n\n#### 输出\n \n```\n\t==== NameTestNew02 ===\n\t===Custom List===\n\tName: Bob EMail: bob.baker@example.com\n\tName: Jane EMail: jane.doe@example.com\n\tName: John EMail: john.doe@example.com\n\tName: James EMail: james.johnson@example.com\n\tName: Joe EMail: joebob.bailey@example.com\n\tName: Phil EMail: phil.smith@examp;e.com\n\tName: Betty EMail: betty.jones@example.com\n\t\n\t===Western List===\n\t\n\tName: Bob Baker\n\tAge: 21  Gender: MALE\n\tEMail: bob.baker@example.com\n\tPhone: 201-121-4678\n\tAddress: 44 4th St, Smallville, KS 12333\n\t\n\tName: Jane Doe\n\tAge: 25  Gender: FEMALE\n\tEMail: jane.doe@example.com\n\tPhone: 202-123-4678\n\tAddress: 33 3rd St, Smallville, KS 12333\n\t\n\tName: John Doe\n\tAge: 25  Gender: MALE\n\tEMail: john.doe@example.com\n\tPhone: 202-123-4678\n\tAddress: 33 3rd St, Smallville, KS 12333\n\t\n\tName: James Johnson\n\tAge: 45  Gender: MALE\n\tEMail: james.johnson@example.com\n\tPhone: 333-456-1233\n\tAddress: 201 2nd St, New York, NY 12111\n\t\n\tName: Joe Bailey\n\tAge: 67  Gender: MALE\n\tEMail: joebob.bailey@example.com\n\tPhone: 112-111-1111\n\tAddress: 111 1st St, Town, CA 11111\n\t\n\tName: Phil Smith\n\tAge: 55  Gender: MALE\n\tEMail: phil.smith@examp;e.com\n\tPhone: 222-33-1234\n\tAddress: 22 2nd St, New Park, CO 222333\n\t\n\tName: Betty Jones\n\tAge: 85  Gender: FEMALE\n\tEMail: betty.jones@example.com\n\tPhone: 211-33-1234\n\tAddress: 22 4th St, New Park, CO 222333\n\t\n\t===Eastern List===\n\t\n\tName: Baker Bob\n\tAge: 21  Gender: MALE\n\tEMail: bob.baker@example.com\n\tPhone: 201-121-4678\n\tAddress: 44 4th St, Smallville, KS 12333\n\t\n\tName: Doe Jane\n\tAge: 25  Gender: FEMALE\n\tEMail: jane.doe@example.com\n\tPhone: 202-123-4678\n\tAddress: 33 3rd St, Smallville, KS 12333\n\t\n\tName: Doe John\n\tAge: 25  Gender: MALE\n\tEMail: john.doe@example.com\n\tPhone: 202-123-4678\n\tAddress: 33 3rd St, Smallville, KS 12333\n\t\n\tName: Johnson James\n\tAge: 45  Gender: MALE\n\tEMail: james.johnson@example.com\n\tPhone: 333-456-1233\n\tAddress: 201 2nd St, New York, NY 12111\n\t\n\tName: Bailey Joe\n\tAge: 67  Gender: MALE\n\tEMail: joebob.bailey@example.com\n\tPhone: 112-111-1111\n\tAddress: 111 1st St, Town, CA 11111\n\t\n\tName: Smith Phil\n\tAge: 55  Gender: MALE\n\tEMail: phil.smith@examp;e.com\n\tPhone: 222-33-1234\n\tAddress: 22 2nd St, New Park, CO 222333\n\t\n\tName: Jones Betty\n\tAge: 85  Gender: FEMALE\n\tEMail: betty.jones@example.com\n\tPhone: 211-33-1234\n\tAddress: 22 4th St, New Park, CO 222333\n```\n\n## lambda表达式和集合\n\n 体验过Function接口的优点还没完，java 8给我们的惊喜还不止这些。（不这些都不够，我必须是你近旁的一只木棉，根紧握地里，也相触云间 ... 神特么的乱入），lambda基础部分结束后，来看看在集合方面它又有哪些优势。\n\n 先看看有哪些不一样的操作符：\n\n * forEach\n * stream\n * filter\n * collection\n * map\n \n> 1.添加新的类，将查询条件全部封装进HashMap中</br>\n\n```\n\tpublic class SearchCriteria {\n\n\t    private final Map<String, MyTest<Person>> searchMap = new HashMap<>();\n\t\n\t    private SearchCriteria() {\n\t        super();\n\t        initSearchMap();\n\t    }\n\t\n\t    private void initSearchMap() {\n\t        MyTest<Person> allDrivers = p -> p.getAge() >= 16;\n\t        MyTest<Person> allDraftees = p -> p.getAge() >= 18 && p.getAge() <= 25 && p.getGender() == Gender.MALE;\n\t        MyTest<Person> allPilots = p -> p.getAge() >= 23 && p.getAge() <= 65;\n\t\n\t        searchMap.put(\"allDrivers\", allDrivers);\n\t        searchMap.put(\"allDraftees\", allDraftees);\n\t        searchMap.put(\"allPilots\", allPilots);\n\t\n\t    }\n\t\n\t    public MyTest<Person> getCriteria(String PredicateName) {\n\t        MyTest<Person> target;\n\t\n\t        target = searchMap.get(PredicateName);\n\t\n\t        if (target == null) {\n\t\n\t            System.out.println(\"Search Criteria not found... \");\n\t            System.exit(1);\n\t\n\t        }\n\t\n\t        return target;\n\t\n\t    }\n\t\n\t    public static SearchCriteria getInstance() {\n\t        return new SearchCriteria();\n\t    }\n\n    }\n\n```\n\n> 2.Looping</br>\n\n> Test01ForEach.java\n\n```\n\tpublic static void main(String[] args) {\n\n        List<Person> pl = Person.createShortList();\n\n        System.out.println(\"\\n=== Western Phone List ===\");\n        pl.forEach(p -> p.printWesternName());\n\n        System.out.println(\"\\n=== Eastern Phone List ===\");\n        pl.forEach(Person::printEasternName);\n\n        System.out.println(\"\\n=== Custom Phone List ===\");\n        pl.forEach(p -> {\n            System.out.println(p.printCustom(r -> \"Name: \" + r.getGivenName() + \" EMail: \" + r.getEmail()));\n        });\n\n    }\n```\n> 3.链式调用和过滤器</br>\n\n> Test02Filter.java\n\n```\n\tpublic class Test02Filter {\n\n\t    public static void main(String[] args) {\n\t\n\t        List<Person> pl = Person.createShortList();\n\t\n\t        SearchCriteria search = SearchCriteria.getInstance();\n\t\n\t        System.out.println(\"\\n=== Western Pilot Phone List ===\");\n\t\n\t        pl.stream().filter(search.getCriteria(\"allPilots\"))\n\t                .forEach(Person::printWesternName);\n\t\n\t\n\t        System.out.println(\"\\n=== Eastern Draftee Phone List ===\");\n\t\n\t        pl.stream().filter(search.getCriteria(\"allDraftees\"))\n\t                .forEach(Person::printEasternName);\n\t\n\t    }\n\n    }\n```\n\n> 4.getting Lazy</br>\n\n  由于篇幅过长，写的有点疲惫，细枝末节的地方，可能没描述清楚，留言里面见；当然这个getting lazy说的并不是我懒\n\n* Laziness：跟java-web的懒加载类似的概念，在前面程序中，循环就采取了了‘lazy’的方式，在filter之后再进行输出，这是一种更为高效的方式\n* Eagerness:Code that performs operations on every object in a list is considered \"eager\". For example, an enhanced for loop that iterates through an entire list to process two objects, is considered a more \"eager\" approach.（ps : 直接给原文了）\n\n#### stream\n\n在上面的代码中，filter之前都会先使用stream,stream方法会将Collection作为输入，返回java.util.stream.Stream接口作为输出。Stream就是集合中元素的序列；默认情况下，一旦元素被调用在stream中将不再有该元素，类似于java中的queuen,因此，每个stream只能被使用一次；另外，stream能变成一个序列在该方法调用之后，后文的例子将印证这一点。\n\n> 转化和结果\n\n 当stream被使用之后被处理，所以在stream中的元素，是无法发生更改；那么如果你还是想在链式操作之后保留stream对应的collection:可以将他们保留在一个新的集合中SHOW CODE :\n\n> Test03toList.java\n\n```\n\tpublic class Test03toList {\n\n    public static void main(String[] args) {\n\n             List<Person> pl = Person.createShortList();\n\n             SearchCriteria search = SearchCriteria.getInstance();\n\n             // Make a new list after filtering.\n             List<Person> pilotList = pl\n                     .stream()\n                     .filter(search.getCriteria(\"allPilots\"))\n                     .collect(Collectors.toList());\n\n             System.out.println(\"\\n=== Western Pilot Phone List ===\");\n             pilotList.forEach(Person::printWesternName);\n\n           }\n\n\t}\n\t\n .collect(Collectors.toList()); 返回一个新的collection\n\n```\n> 集合中的计算\n\n map()通常和filter成对出现，map会从对象里抽出某个属性，来执行一些操作，下面的例子以age作为主要的操作字段，来呈现集合中计算的用法\n\n> Test04Map.java\n> \n```\n\tpublic class Test04Map {\n\n    public static void main(String[] args) {\n         List<Person> pl = Person.createShortList();\n\n         SearchCriteria search = SearchCriteria.getInstance();\n\n         // Calc average age of pilots old style\n         System.out.println(\"== Calc Old Style ==\");\n         int sum = 0;\n         int count = 0;\n\n         for (Person p:pl){\n           if (p.getAge() >= 23 && p.getAge() <= 65 ){\n             sum = sum + p.getAge();\n             count++;\n           }\n         }\n\n         long average = sum / count;\n         System.out.println(\"Total Ages: \" + sum);\n         System.out.println(\"Average Age: \" + average);\n\n\n         // Get sum of ages\n         System.out.println(\"\\n== Calc New Style ==\");\n         long totalAge = pl\n                 .stream()\n                 .filter(search.getCriteria(\"allPilots\"))\n                 .mapToInt(p -> p.getAge())\n                 .sum();\n\n         // Get average of ages\n         OptionalDouble averageAge = pl\n                 .parallelStream()\n                 .filter(search.getCriteria(\"allPilots\"))\n                 .mapToDouble(p -> p.getAge())\n                 .average();\n\n         System.out.println(\"Total Ages: \" + totalAge);\n         System.out.println(\"Average Age: \" + averageAge.getAsDouble());\n\n       }\n\n\t}\n```\n\n### 结语\n  \n  总算是写完了，博客后面写得不是很走心，但是还是比较开心，又一次通过官方文档，完成了一个知识点：另外由于篇幅问题，Android Studio中如何引入java 8将在另外一篇博客中说明，lambda就到这里了，欢迎勘误。\n\n### 参考文档\n\n [oracle 官方教程](http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/Lambda-QuickStart/index.html#section3)\n\n \n\n\n \n\n\n\n\n\n\n\t\n\n\n\n\n\n\n","tags":["java8新特性"]},{"title":"About me","url":"/2018/12/26/About-me/","content":"\n 近期发现了一个android大神[Hencoder](http://hencoder.com/)文风很程序员，话说什么才叫程序员风格，这个我就有话要说，一个优秀的程序员，必定得瑟，字里行间透漏着对自己深深的痴迷，谁敢recode自己的代码就跟谁玩命的自信，以及莫名其妙的冷段子和一大堆奇奇怪怪的表情包，当然最重要的是能够幽默风趣的表达。\n\n 又扯远了（ps:这也是程序员文风常用的伎俩），既然是about me,干嘛要提hencoder? emmm .... 突然想到的，膜拜大神这个理由应该可以吧。\n\n 7月底的时候，其实就学了怎么搭建博客，学会了又有啥用（做个摊手表情），苦于没内容还爱打dota2,也不知道更新什么。这次又斗胆前来，应该不鸽,太久没动过hexo，抽空在公司又温习了一次。\n\n 关于目的：肯定是为了以后跟人聊天的时候，可以装一波bi,毕竟身边都是coder,别人都在显摆的时候站在边上看别人装逼，那应该不是我的风格。\n\n### 关于我：\n Android 程序员 （真瘠薄简单的自我介绍，我也需要一些tag）\n \n 关于博客内容：\n Android基本知识的深入\n 各种机制的详解\n RxJava的深入理解\n 设计模式的学习和运用\n Kotlin学习\n \n### 结语\n \n 总之都是学习的一些记录，希望自己能有所突破。\n \n\n\n\n\n\n"}]
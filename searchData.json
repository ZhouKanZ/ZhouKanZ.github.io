[{"url":"/2018/12/26/README/","content":"# MardDwonTemp\n\n博客文章的暂存地\n\n"},{"url":"/2018/12/26/Java8-lambda表达式/","content":"## java 8 Lambda表达式\n\n\n### 介绍\n \n本篇文章主要是RxJava官方文档的辅料，里面太多的Lambda表达式，没有一些了解的确难以看懂，因为是主要的重心还是落在RxJava上，所以本文概述一下如何在Android Studio中使用以及各个表达式的意思，还有与Rxjava及其相似的stream。[官方文档](http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/Lambda-QuickStart/index.html#)如何描述Lambda表达式：\n\n>  Lambda expressions are a new and important feature included in Java SE 8. They provide a clear and concise way to represent one method interface using an expression. Lambda expressions also improve the Collection libraries making it easier to iterate through, filter, and extract data from a Collection. In addition, new concurrency features improve performance in multicore environments.\n\n这段话指出了在java8中lambda表达式三个主要的作用：简洁的方式呈现接口；提高集合迭代，过滤和扩展的性能；提高多核环境下并发的性能。具体的翻译还是大家自行去理解，中英转换肯定会出现一定的偏差。\n\n### 软硬件环境\n\n* JDK 8\n* NetBeans 7.4 （这个只是IDE 在Android Studio中同样是可以使用的）\n\n## Lambda应用在那些场景呢？因为不知道怎么翻译合适就直接上英语了.\n\n#### Anonymous Inner Class\n\t\n 匿名内部类，用过java的人这个应该都知道就不再赘述\n\n\t// 匿名内部类\n\tJButton jb1 = new JButton();\n\tjb1.addActionListener(new ActionListener() {\n\t    @Override\n\t    public void actionPerformed(ActionEvent e) {\n\t        System.out.println(\"xxx\");\n\t    }\n\t});\n   \n    // lambda表达式的方式\n\tJButton jb = new JButton();\n\tjb.addActionListener((e) -> System.out.println());\n\n#### Functional Interface\n\n在java中，一个interface里面只有一个需要实现的方法，这种形式的接口就被称作为Functional Interface,也被叫做SAM.(Single Abstract Method)\n\tpublic interface ActionListener extends EventListener {\n\t\n\t    /**\n\t     * Invoked when an action occurs.\n\t     */\n\t    public void actionPerformed(ActionEvent e);\n\t\n\t}\n \n\n#### Lambda Expression Syntax \n\n λ表达式的语法，通常λ表达式可以将5行代码，转换成一行代码来表示，上面的匿名内部类便是例子，λ表达式的语法由如下三个部分组成：\n\n|参数列表|箭头|方法体|\n| ------------- |:-------------|:-------------|\n|（int x,int y）|->|x + y|\n\n\n## lambda表达式实例\n\n\n#### Listener Lambda\n\tprivate static void listenerLambda() {\n        //        Listener Lambda\n        JButton jb1 = new JButton();\n        jb1.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                System.out.println(\"xxx\");\n            }\n        });\n\n        // lambda表达式的方式\n        JButton jb = new JButton();\n        jb.addActionListener((e) -> System.out.println());\n    }\n\n\n#### Comparator Lambda\n\n    private static void compatorLambda() {\n        // sort with inner class\n        List<Person> personList = new ArrayList<>();\n        personList.add(new Person(\"zk\"));\n        personList.add(new Person(\"ak\"));\n\n\n        System.out.println(\"sort with inner class\");\n        Collections.sort(personList, new Comparator<Person>() {\n            @Override\n            public int compare(Person o1, Person o2) {\n                // 按照字典序排列 person\n                return o1.getSurName().compareTo(o2.getSurName());\n            }\n        });\n\n        for (Person p:\n                personList) {\n            System.out.println(p.getSurName());\n        }\n\n\n        System.out.println(\"sort with lambda\");\n        // sort with lambda\n        Collections.sort(personList, (p1,p2)->p1.getSurName().compareTo(p2.getSurName()));\n        for (Person p:\n                personList) {\n            System.out.println(p.getSurName());\n        }\n    }\n\n\n#### Runnable Lambda\n\n    private static void runnableLambda() {\n        // 传统模式\n        Runnable r1 = new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(\"Tran  A\");\n                System.out.println(\"Tran  B\");\n            }\n        };\n\n        // lambda\n        Runnable r2 = () -> System.out.print(\"Lambda  A\");\n        System.out.print(\"Lambda  B\");\n\n        r1.run();\n        r2.run();\n    }\n\n## Improving Code with Lambda Expression \n\n 使用Lambda优化代码。代码优化这件事可轻可重，像我写代码的主要目的就是奔着功能去，一往无前，有bug回头改,往往都是一去不返。代码优化有很多方面，像6大设计原则，23种设计模式等等，今天得例子要验证得Principle叫做 --- 'Don't Repeat Yourself ' 简称 (DRY)，不得不说所有得原则全称都不如简称有格调。\n\n 那下面我们就来验证一下lambda相对于原有得做法到底 DRY 在哪里：\n\n> 1.场景 \n  \n 有一群人来面试,只招聘司机、应征入伍、飞行员，面试得条件如下：\n \t\n\t司机 ： 年纪超过16\n    入伍 ： 男性年龄在18-25之间\n    飞行员：年龄在23 到 65之间\n\n Person 字段 \n\n\tpublic class Person {\n    private String givenName;\n    private String surName;\n    private int age;\n    private Gender gender;\n    private String eMail;\n    private String phone;\n    private String address;\t\n\n> 2.创建person List\n\n   怎么创建比较随意，我这里就按照官网得方式来创建（在上一篇RxJava中有关于设计模式得附录）\n\n   \tpublic static List<Person> createShortList() {\n        List<Person> people = new ArrayList<>();\n        people.add(\n                new Person.Builder().\n                        givenName(\"Bob\")\n                        .surName(\"Baker\")\n                        .age(21)\n                        .gender(Gender.MALE)\n                        .email(\"bob.baker@example.com\")\n                        .phoneNumber(\"201-121-4678\")\n                        .address(\"44 4th St, Smallville, KS 12333\")\n                        .build()\n        );\n        people.add(\n                new Person.Builder()\n                        .givenName(\"Jane\")\n                        .surName(\"Doe\")\n                        .age(25)\n                        .gender(Gender.FEMALE)\n                        .email(\"jane.doe@example.com\")\n                        .phoneNumber(\"202-123-4678\")\n                        .address(\"33 3rd St, Smallville, KS 12333\")\n                        .build()\n        );\n        people.add(\n                new Person.Builder()\n                        .givenName(\"John\")\n                        .surName(\"Doe\")\n                        .age(25)\n                        .gender(Gender.MALE)\n                        .email(\"john.doe@example.com\")\n                        .phoneNumber(\"202-123-4678\")\n                        .address(\"33 3rd St, Smallville, KS 12333\")\n                        .build()\n        );\n\n        return people;\n    }\n\n> 3.选出你所要挑选的满足条件的人\n\n\tpublic class RoboContactMethods {\n\n\t    public void callDrivers(List<Person> pl) {\n\t        for (Person p : pl) {\n\t            if (p.getAge() >= 16) {\n\t                roboCall(p);\n\t            }\n\t        }\n\t    }\n\t\n\t    public void emailDraftees(List<Person> pl) {\n\t        for (Person p : pl) {\n\t            if (p.getAge() >= 18 && p.getAge() <= 25 && p.getGender() == Gender.MALE) {\n\t                roboEmail(p);\n\t            }\n\t        }\n\t    }\n\t\n\t    public void mailPilots(List<Person> pl) {\n\t        for (Person p : pl) {\n\t            if (p.getAge() >= 23 && p.getAge() <= 65) {\n\t                roboMail(p);\n\t            }\n\t        }\n\t    }\n\t\n\t    public void roboCall(Person p) {\n\t        System.out.println(\"Calling \" + p.getGivenName() + \" \" + p.getSurName() + \" age \" + p.getAge() + \" at \" + p.getPhone());\n\t    }\n\t\n\t    public void roboEmail(Person p) {\n\t        System.out.println(\"EMailing \" + p.getGivenName() + \" \" + p.getSurName() + \" age \" + p.getAge() + \" at \" + p.geteMail());\n\t    }\n\t\n\t    public void roboMail(Person p) {\n\t        System.out.println(\"Mailing \" + p.getGivenName() + \" \" + p.getSurName() + \" age \" + p.getAge() + \" at \" + p.getAddress());\n\t    }\n\n\t}\n\n我看这段代码是没问题的，for循环迭代选出满足条件的人，完全没毛病；那我们来看看官方的犊子是怎么演的。\n\n* 没有遵循DRY原则\n\t- 每个方法的选择条件必须重写\n\t- 每个方法都重复循环\n* 需要大量方法来实现每个用例\n* 上述代码不灵活，如果招聘条件发生变化，那么将引起大量的更改，可维护性不强\n\n\n>4.第一次重构\n\t\n 这次我们将上述的几个问题列入考虑，其实，我感觉我的翻译貌似出了点小差错，或者是我没明白他是什么意思，除了最后一项可以理解之外，其他的情况没弄懂是什么意思，再或者是本身语言的限制只能优化最后一项，那么下面看看，该如何重构。\n\n\tpublic class RoboContactMethods2 {\n\n\n    public void callDrivers(List<Person> pl) {\n        for (Person p : pl) {\n            if (isDriver(p)) {\n                roboCall(p);\n            }\n        }\n    }\n\n    public void emailDraftees(List<Person> pl) {\n        for (Person p : pl) {\n            if (isDraftee(p)) {\n                roboEmail(p);\n            }\n        }\n    }\n\n    public void mailPilots(List<Person> pl) {\n        for (Person p : pl) {\n            if (isPilot(p)) {\n                roboMail(p);\n            }\n        }\n    }\n\n    public boolean isDriver(Person p) {\n        return p.getAge() >= 16;\n    }\n\n    public boolean isDraftee(Person p) {\n        return p.getAge() >= 18 && p.getAge() <= 25 && p.getGender() == Gender.MALE;\n    }\n\n    public boolean isPilot(Person p) {\n        return p.getAge() >= 23 && p.getAge() <= 65;\n    }\n\n    public void roboCall(Person p) {\n        System.out.println(\"Calling \" + p.getGivenName() + \" \" + p.getSurName() + \" age \" + p.getAge() + \" at \" + p.getPhone());\n    }\n\n    public void roboEmail(Person p) {\n        System.out.println(\"EMailing \" + p.getGivenName() + \" \" + p.getSurName() + \" age \" + p.getAge() + \" at \" + p.geteMail());\n    }\n\n    public void roboMail(Person p) {\n        System.out.println(\"Mailing \" + p.getGivenName() + \" \" + p.getSurName() + \" age \" + p.getAge() + \" at \" + p.getAddress());\n    }\n\n}\n\n 搜索条件被封装进方法中，较之前的代码而言确实有一定的提升，条件可以被反复利用并且可以更方便的更改。但是，还是有很多重复的地方，是不是没有更好的办法呢？（······肯定是有的，要不我说个球）\n\n 在使用lambda之前先看看还有什么能改进的或者是为lambda做一些铺垫。上述的代码，其实并不符合开闭原则（OCP -- 原则上对修改关闭，对扩展开放），这段程序可能发生改变是招聘条件，那么我们让调用程序自己去维护，就更进一步的优化了。\n \n 将条件抽象成接口，让调用者自己去维护，接口如下：\n \n\t public interface MyTest<T> {\n\t   public boolean test(T t);\n\t }\n\n> RoboContactsAnon.java\n\n\n  \tpackage com.example.lambda;\n  \timport java.util.List;\n  \timport java.util.function.Predicate;\n\n    /**\n     * @author MikeW\n     */\n    public class RoboContactsAnon {\n        public void phoneContacts(List<Person> pl, MyTest<Person> pred) {\n            for (Person p : pl) {\n                if (pred.test(p)) {\n                    roboCall(p);\n                }\n            }\n        }\n\n        public void emailContacts(List<Person> pl, MyTest<Person> pred) {\n            for (Person p : pl) {\n                if (pred.test(p)) {\n                    roboEmail(p);\n                }\n            }\n        }\n\n        public void mailContacts(List<Person> pl, MyTest<Person> pred) {\n            for (Person p : pl) {\n                if (pred.test(p)) {\n                    roboMail(p);\n                }\n            }\n        }\n\n        public void roboCall(Person p) {\n            System.out.println(\"Calling \" + p.getGivenName() + \" \" + p.getSurName() + \" age \" + p.getAge() + \" at \" + p.getPhone());\n        }\n\n        public void roboEmail(Person p) {\n            System.out.println(\"EMailing \" + p.getGivenName() + \" \" + p.getSurName() + \" age \" + p.getAge() + \" at \" + p.getEmail());\n        }\n\n        public void roboMail(Person p) {\n            System.out.println(\"Mailing \" + p.getGivenName() + \" \" + p.getSurName() + \" age \" + p.getAge() + \" at \" + p.getAddress());\n        }\n    }\n \n> RoboCallTest03.java 调用程序\n\n\tpublic class RoboCallTest03 {\n\n\t    public static void main(String[] args) {\n\t\n\t      List<Person> pl = Person.createShortList();\n\t      RoboContactsAnon robo = new RoboContactsAnon();\n\t\n\t      System.out.println(\"\\n==== Test 03 ====\");\n\t      System.out.println(\"\\n=== Calling all Drivers ===\");\n\t      robo.phoneContacts(pl,\n\t          new MyTest<Person>(){\n\t            @Override\n\t            public boolean test(Person p){\n\t              return p.getAge() >=16;\n\t            }\n\t          }\n\t      );\n\t\n\t      System.out.println(\"\\n=== Emailing all Draftees ===\");\n\t      robo.emailContacts(pl,\n\t          new MyTest<Person>(){\n\t            @Override\n\t            public boolean test(Person p){\n\t              return p.getAge() >= 18 && p.getAge() <= 25 && p.getGender() == Gender.MALE;\n\t            }\n\t          }\n\t      );\n\t\n\t\n\t      System.out.println(\"\\n=== Mail all Pilots ===\");\n\t      robo.mailContacts(pl,\n\t          new MyTest<Person>(){\n\t            @Override\n\t            public boolean test(Person p){\n\t              return p.getAge() >= 23 && p.getAge() <= 65;\n\t            }\n\t          }\n\t      );\n   \t  }\n\t}\n\n  仅通过java8之前得方式，程序看起来已经符合OCP的原则；在前面提到过SAM这种形式是可以用，lambda来表示的。那么看看如何去用lambda,来进一步的优化上面的程序\n\n> lambda 优化\n\n 在java.util.function包中提供了一种形式类似的MyTest的接口，Predicate<T>；\n \n\t public interface Predicate<T> {\n\t   public boolean test(T t);\n\t }\n\n> RoboContactsLambda.java\n\n    package com.example.lambda;\n    import java.util.List;\n    import java.util.function.Predicate;\n\n    /**\n     * @authorzhoukan\n     */\n    public class RoboContactLambda {\n        public void phoneContacts(List<Person> pl, Predicate<Person> pred) {\n            for (Person p : pl) {\n                if (pred.test(p)) {\n                    roboCall(p);\n                }\n            }\n        }\n\n        public void emailContacts(List<Person> pl, Predicate<Person> pred) {\n            for (Person p : pl) {\n                if (pred.test(p)) {\n                    roboEmail(p);\n                }\n            }\n        }\n\n        public void mailContacts(List<Person> pl, Predicate<Person> pred) {\n            for (Person p : pl) {\n                if (pred.test(p)) {\n                    roboMail(p);\n                }\n            }\n        }\n\n        public void roboCall(Person p) {\n            System.out.println(\"Calling \" + p.getGivenName() + \" \" + p.getSurName() + \" age \" + p.getAge() + \" at \" + p.getPhone());\n        }\n\n        public void roboEmail(Person p) {\n            System.out.println(\"EMailing \" + p.getGivenName() + \" \" + p.getSurName() + \" age \" + p.getAge() + \" at \" + p.getEmail());\n        }\n\n        public void roboMail(Person p) {\n            System.out.println(\"Mailing \" + p.getGivenName() + \" \" + p.getSurName() + \" age \" + p.getAge() + \" at \" + p.getAddress());\n        }\n    }\n\n Mytest接口被更换成了Predicate,调用程序的代码片段如下\n\n\tpublic static void main(String[] args){ \n\t\t\n\t\t List<Person> pl = Person.createShortList();\n\t     RoboContactLambda robo = new RoboContactLambda();\n\n\t\t Predicate<Person> allDrivers = p -> p.getAge() >= 16;\n         robo.phoneContacts(pl, allDrivers);\n\t}\n\n 当然即使不适用util.function提供的接口，也是可以实现了，只要满足lambda表达式的场景就好：\n\n   \t\trobo.mailContacts(pl,\n          /*new MyTest<Person>(){\n            @Override\n            public boolean test(Person p){\n              return p.getAge() >= 23 && p.getAge() <= 65;\n            }\n          }*/\n                (p) -> p.getAge() > 23 && p.getAge() <= 65\n        );\n\n\n## The java.util.function 包\n\n\n function包提供了几种方便去使用lambda的interface，当然不仅仅是给lambda表达式使用，所有诸如上述的优化都是可以考虑用这些方法的，确实我看到这里就有点抑制不住内心的小狂喜，lambda的这些function不就是Rxjava中常用的操作符嘛，这么麻烦的工作算是没白做，就下面的需求，我们来体验一下她的魅力。\n\n* Predicate: A property of the object passed as argument\n* Consumer: An action to be performed with the object passed as argument\n* Function: Transform a T to a U\n* Supplier: Provide an instance of a T (such as a factory)\n* UnaryOperator: A unary operator from T -> T\n* BinaryOperator: A binary operator from (T, T) -> T\n\n\n> 输出东方人和西方人的信息\n \n  上面的personList（求职者），要将他们的信息分别发给，老板和老板娘，他们一个是中国人，一个是美国人；由于习惯不同，西方习惯姓在后名在前（分别对应Given name 和 surname），中国的习惯我就不提了。\n\n#### 传统的方式\n\n  person.java\n\n   \tpublic void printWesternName() {\n\n        System.out.println(\"\\nName: \" + this.getGivenName() + \" \" + this.getSurName() + \"\\n\" +\n                \"Age: \" + this.getAge() + \"  \" + \"Gender: \" + this.getGender() + \"\\n\" +\n                \"EMail: \" + this.geteMail() + \"\\n\" +\n                \"Phone: \" + this.getPhone() + \"\\n\" +\n                \"Address: \" + this.getAddress());\n    }\n\n\n    public void printEasternName() {\n\n        System.out.println(\"\\nName: \" + this.getSurName() + \" \" + this.getGivenName() + \"\\n\" +\n                \"Age: \" + this.getAge() + \"  \" + \"Gender: \" + this.getGender() + \"\\n\" +\n                \"EMail: \" + this.geteMail() + \"\\n\" +\n                \"Phone: \" + this.getPhone() + \"\\n\" +\n                \"Address: \" + this.getAddress());\n    }  \n\n#### 使用Function Interface的方式\n \n \tpublic interface Function<R,T>{\n        public R apply(T t);\n\t}\n\n  指定两个泛型以T作为输入，R作为输出，那么对于上述场景而言 -> Function<string,person>，用function来更灵活的实现打印方法：\n  \n  Person.java\n\n\tpublic String printCustom(Function <Person, String> f){\n\t      return f.apply(this);\n\t}\n\n> 调用程序 NameTestNew.java\n\n  \tpublic class NameTestNew {\n        public static void main(String[] args) {\n\n            System.out.println(\"\\n==== NameTestNew02 ===\");\n\n            List<Person> list1 = Person.createShortList();\n\n            // Print Custom First Name and e-mail\n            System.out.println(\"===Custom List===\");\n            for (Person person : list1) {\n                System.out.println(\n                        person.printCustom(p -> \"Name: \" + p.getGivenName() + \" EMail: \" + p.getEmail())\n                );\n            }\n\n\n            // Define Western and Eastern Lambdas\n\n            Function<Person, String> westernStyle = p -> {\n                return \"\\nName: \" + p.getGivenName() + \" \" + p.getSurName() + \"\\n\" +\n                        \"Age: \" + p.getAge() + \"  \" + \"Gender: \" + p.getGender() + \"\\n\" +\n                        \"EMail: \" + p.getEmail() + \"\\n\" +\n                        \"Phone: \" + p.getPhone() + \"\\n\" +\n                        \"Address: \" + p.getAddress();\n            };\n\n            Function<Person, String> easternStyle = p -> \"\\nName: \" + p.getSurName() + \" \"\n                    + p.getGivenName() + \"\\n\" + \"Age: \" + p.getAge() + \"  \" +\n                    \"Gender: \" + p.getGender() + \"\\n\" +\n                    \"EMail: \" + p.getEmail() + \"\\n\" +\n                    \"Phone: \" + p.getPhone() + \"\\n\" +\n                    \"Address: \" + p.getAddress();\n\n            // Print Western List\n            System.out.println(\"\\n===Western List===\");\n            for (Person person : list1) {\n                System.out.println(\n                        person.printCustom(westernStyle)\n                );\n            }\n\n            // Print Eastern List\n            System.out.println(\"\\n===Eastern List===\");\n            for (Person person : list1) {\n                System.out.println(\n                        person.printCustom(easternStyle)\n                );\n            }\n\n\n        }\n    } \n\n 第一次循环只输出了名和email,所有有效的表达式都能作为printCustom的参数；第二次，首先将东方人和西方人的输出方式定义为Fucntion，并当作参数传入printCustom中。lambda表达式利于扩展和反复利用的优势得以体现。\n\n#### 输出\n \n\t==== NameTestNew02 ===\n\t===Custom List===\n\tName: Bob EMail: bob.baker@example.com\n\tName: Jane EMail: jane.doe@example.com\n\tName: John EMail: john.doe@example.com\n\tName: James EMail: james.johnson@example.com\n\tName: Joe EMail: joebob.bailey@example.com\n\tName: Phil EMail: phil.smith@examp;e.com\n\tName: Betty EMail: betty.jones@example.com\n\t\n\t===Western List===\n\t\n\tName: Bob Baker\n\tAge: 21  Gender: MALE\n\tEMail: bob.baker@example.com\n\tPhone: 201-121-4678\n\tAddress: 44 4th St, Smallville, KS 12333\n\t\n\tName: Jane Doe\n\tAge: 25  Gender: FEMALE\n\tEMail: jane.doe@example.com\n\tPhone: 202-123-4678\n\tAddress: 33 3rd St, Smallville, KS 12333\n\t\n\tName: John Doe\n\tAge: 25  Gender: MALE\n\tEMail: john.doe@example.com\n\tPhone: 202-123-4678\n\tAddress: 33 3rd St, Smallville, KS 12333\n\t\n\tName: James Johnson\n\tAge: 45  Gender: MALE\n\tEMail: james.johnson@example.com\n\tPhone: 333-456-1233\n\tAddress: 201 2nd St, New York, NY 12111\n\t\n\tName: Joe Bailey\n\tAge: 67  Gender: MALE\n\tEMail: joebob.bailey@example.com\n\tPhone: 112-111-1111\n\tAddress: 111 1st St, Town, CA 11111\n\t\n\tName: Phil Smith\n\tAge: 55  Gender: MALE\n\tEMail: phil.smith@examp;e.com\n\tPhone: 222-33-1234\n\tAddress: 22 2nd St, New Park, CO 222333\n\t\n\tName: Betty Jones\n\tAge: 85  Gender: FEMALE\n\tEMail: betty.jones@example.com\n\tPhone: 211-33-1234\n\tAddress: 22 4th St, New Park, CO 222333\n\t\n\t===Eastern List===\n\t\n\tName: Baker Bob\n\tAge: 21  Gender: MALE\n\tEMail: bob.baker@example.com\n\tPhone: 201-121-4678\n\tAddress: 44 4th St, Smallville, KS 12333\n\t\n\tName: Doe Jane\n\tAge: 25  Gender: FEMALE\n\tEMail: jane.doe@example.com\n\tPhone: 202-123-4678\n\tAddress: 33 3rd St, Smallville, KS 12333\n\t\n\tName: Doe John\n\tAge: 25  Gender: MALE\n\tEMail: john.doe@example.com\n\tPhone: 202-123-4678\n\tAddress: 33 3rd St, Smallville, KS 12333\n\t\n\tName: Johnson James\n\tAge: 45  Gender: MALE\n\tEMail: james.johnson@example.com\n\tPhone: 333-456-1233\n\tAddress: 201 2nd St, New York, NY 12111\n\t\n\tName: Bailey Joe\n\tAge: 67  Gender: MALE\n\tEMail: joebob.bailey@example.com\n\tPhone: 112-111-1111\n\tAddress: 111 1st St, Town, CA 11111\n\t\n\tName: Smith Phil\n\tAge: 55  Gender: MALE\n\tEMail: phil.smith@examp;e.com\n\tPhone: 222-33-1234\n\tAddress: 22 2nd St, New Park, CO 222333\n\t\n\tName: Jones Betty\n\tAge: 85  Gender: FEMALE\n\tEMail: betty.jones@example.com\n\tPhone: 211-33-1234\n\tAddress: 22 4th St, New Park, CO 222333\n\t\n\n## lambda表达式和集合\n\n 体验过Function接口的优点还没完，java 8给我们的惊喜还不止这些。（不这些都不够，我必须是你近旁的一只木棉，根紧握地里，也相触云间 ... 神特么的乱入），lambda基础部分结束后，来看看在集合方面它又有哪些优势。\n\n 先看看有哪些不一样的操作符：\n\n * forEach\n * stream\n * filter\n * collection\n * map\n \n> 1.添加新的类，将查询条件全部封装进HashMap中</br>\n\n\tpublic class SearchCriteria {\n\n\t    private final Map<String, MyTest<Person>> searchMap = new HashMap<>();\n\t\n\t    private SearchCriteria() {\n\t        super();\n\t        initSearchMap();\n\t    }\n\t\n\t    private void initSearchMap() {\n\t        MyTest<Person> allDrivers = p -> p.getAge() >= 16;\n\t        MyTest<Person> allDraftees = p -> p.getAge() >= 18 && p.getAge() <= 25 && p.getGender() == Gender.MALE;\n\t        MyTest<Person> allPilots = p -> p.getAge() >= 23 && p.getAge() <= 65;\n\t\n\t        searchMap.put(\"allDrivers\", allDrivers);\n\t        searchMap.put(\"allDraftees\", allDraftees);\n\t        searchMap.put(\"allPilots\", allPilots);\n\t\n\t    }\n\t\n\t    public MyTest<Person> getCriteria(String PredicateName) {\n\t        MyTest<Person> target;\n\t\n\t        target = searchMap.get(PredicateName);\n\t\n\t        if (target == null) {\n\t\n\t            System.out.println(\"Search Criteria not found... \");\n\t            System.exit(1);\n\t\n\t        }\n\t\n\t        return target;\n\t\n\t    }\n\t\n\t    public static SearchCriteria getInstance() {\n\t        return new SearchCriteria();\n\t    }\n\n    }\n\n> 2.Looping</br>\n\n> Test01ForEach.java\n\n\tpublic static void main(String[] args) {\n\n        List<Person> pl = Person.createShortList();\n\n        System.out.println(\"\\n=== Western Phone List ===\");\n        pl.forEach(p -> p.printWesternName());\n\n        System.out.println(\"\\n=== Eastern Phone List ===\");\n        pl.forEach(Person::printEasternName);\n\n        System.out.println(\"\\n=== Custom Phone List ===\");\n        pl.forEach(p -> {\n            System.out.println(p.printCustom(r -> \"Name: \" + r.getGivenName() + \" EMail: \" + r.getEmail()));\n        });\n\n    }\n> 3.链式调用和过滤器</br>\n\n> Test02Filter.java\n\tpublic class Test02Filter {\n\n\t    public static void main(String[] args) {\n\t\n\t        List<Person> pl = Person.createShortList();\n\t\n\t        SearchCriteria search = SearchCriteria.getInstance();\n\t\n\t        System.out.println(\"\\n=== Western Pilot Phone List ===\");\n\t\n\t        pl.stream().filter(search.getCriteria(\"allPilots\"))\n\t                .forEach(Person::printWesternName);\n\t\n\t\n\t        System.out.println(\"\\n=== Eastern Draftee Phone List ===\");\n\t\n\t        pl.stream().filter(search.getCriteria(\"allDraftees\"))\n\t                .forEach(Person::printEasternName);\n\t\n\t    }\n\n    }\n\n\n> 4.getting Lazy</br>\n\n  由于篇幅过长，写的有点疲惫，细枝末节的地方，可能没描述清楚，留言里面见；当然这个getting lazy说的并不是我懒\n\n* Laziness：跟java-web的懒加载类似的概念，在前面程序中，循环就采取了了‘lazy’的方式，在filter之后再进行输出，这是一种更为高效的方式\n* Eagerness:Code that performs operations on every object in a list is considered \"eager\". For example, an enhanced for loop that iterates through an entire list to process two objects, is considered a more \"eager\" approach.（ps : 直接给原文了）\n\n#### stream\n\n在上面的代码中，filter之前都会先使用stream,stream方法会将Collection作为输入，返回java.util.stream.Stream接口作为输出。Stream就是集合中元素的序列；默认情况下，一旦元素被调用在stream中将不再有该元素，类似于java中的queuen,因此，每个stream只能被使用一次；另外，stream能变成一个序列在该方法调用之后，后文的例子将印证这一点。\n\n> 转化和结果\n\n 当stream被使用之后被处理，所以在stream中的元素，是无法发生更改；那么如果你还是想在链式操作之后保留stream对应的collection:可以将他们保留在一个新的集合中SHOW CODE :\n\n> Test03toList.java\n\n\tpublic class Test03toList {\n\n    public static void main(String[] args) {\n\n             List<Person> pl = Person.createShortList();\n\n             SearchCriteria search = SearchCriteria.getInstance();\n\n             // Make a new list after filtering.\n             List<Person> pilotList = pl\n                     .stream()\n                     .filter(search.getCriteria(\"allPilots\"))\n                     .collect(Collectors.toList());\n\n             System.out.println(\"\\n=== Western Pilot Phone List ===\");\n             pilotList.forEach(Person::printWesternName);\n\n           }\n\n\t}\n\t\n .collect(Collectors.toList()); 返回一个新的collection\n \n> 集合中的计算\n\n map()通常和filter成对出现，map会从对象里抽出某个属性，来执行一些操作，下面的例子以age作为主要的操作字段，来呈现集合中计算的用法\n\n> Test04Map.java\n\n\tpublic class Test04Map {\n\n    public static void main(String[] args) {\n         List<Person> pl = Person.createShortList();\n\n         SearchCriteria search = SearchCriteria.getInstance();\n\n         // Calc average age of pilots old style\n         System.out.println(\"== Calc Old Style ==\");\n         int sum = 0;\n         int count = 0;\n\n         for (Person p:pl){\n           if (p.getAge() >= 23 && p.getAge() <= 65 ){\n             sum = sum + p.getAge();\n             count++;\n           }\n         }\n\n         long average = sum / count;\n         System.out.println(\"Total Ages: \" + sum);\n         System.out.println(\"Average Age: \" + average);\n\n\n         // Get sum of ages\n         System.out.println(\"\\n== Calc New Style ==\");\n         long totalAge = pl\n                 .stream()\n                 .filter(search.getCriteria(\"allPilots\"))\n                 .mapToInt(p -> p.getAge())\n                 .sum();\n\n         // Get average of ages\n         OptionalDouble averageAge = pl\n                 .parallelStream()\n                 .filter(search.getCriteria(\"allPilots\"))\n                 .mapToDouble(p -> p.getAge())\n                 .average();\n\n         System.out.println(\"Total Ages: \" + totalAge);\n         System.out.println(\"Average Age: \" + averageAge.getAsDouble());\n\n       }\n\n\t}\n\n## 结语\n  \n  总算是写完了，博客后面写得不是很走心，但是还是比较开心，有一次通过官方文档，完成了一个知识点：另外由于篇幅问题，Android Studio中如何引入java 8将在另外一篇博客中说明，lambda就到这里了，欢迎勘误。\n\n#### 文档 ：\n\n [oracle 官方教程](http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/Lambda-QuickStart/index.html#section3)\n\n \n\n\n \n\n\n\n\n\n\n\t\n\n\n\n\n\n\n"},{"title":"Hello World","url":"/2018/12/26/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n"}]